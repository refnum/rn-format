#!/usr/bin/ruby -w
#==============================================================================
#	NAME:
#		rn-format
#
#	DESCRIPTION:
#		clang-format source code formatter.
#
#	COPYRIGHT:
#		Copyright (c) 2019, refNum Software
#		<http://www.refnum.com/>
#
#		All rights reserved.
#
#		Redistribution and use in source and binary forms, with or without
#		modification, are permitted provided that the following conditions
#		are met:
#
#			o Redistributions of source code must retain the above
#			copyright notice, this list of conditions and the following
#			disclaimer.
#
#			o Redistributions in binary form must reproduce the above
#			copyright notice, this list of conditions and the following
#			disclaimer in the documentation and/or other materials
#			provided with the distribution.
#
#			o Neither the name of refNum Software nor the names of its
#			contributors may be used to endorse or promote products derived
#			from this software without specific prior written permission.
#
#		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#		"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#		LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#		A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#		OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#		SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#		LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#		DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#		THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#		(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#		OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#==============================================================================
# Imports
#------------------------------------------------------------------------------
require 'fileutils';
require 'find';
require 'optparse';
require 'tmpdir';





#==============================================================================
#		Constants
#------------------------------------------------------------------------------
# Paths
#
PATH_CLANG_FORMAT = `which clang-format`.chomp;
PATH_UNCRUSTIFY   = `which uncrustify`.chomp;

FILE_CONFIG_UNCRUSTIFY = "uncrustify.cfg";


# Configuration
#
CONFIG_CLANG_FORMAT=<<FRAGMENT
# ============================================================
# https://clang.llvm.org/docs/ClangFormatStyleOptions.html
# ------------------------------------------------------------
---
AccessModifierOffset:									-4
AlignAfterOpenBracket:									Align
AlignConsecutiveAssignments:							true
AlignConsecutiveDeclarations:							true
AlignConsecutiveMacros:									true
AlignEscapedNewlines:									Left
AlignOperands:											true
AlignTrailingComments:									true
AllowAllArgumentsOnNextLine:							false
AllowAllConstructorInitializersOnNextLine:				false
AllowAllParametersOfDeclarationOnNextLine:				false
AllowShortBlocksOnASingleLine:							false
AllowShortCaseLabelsOnASingleLine:						false
AllowShortFunctionsOnASingleLine:						None
AllowShortIfStatementsOnASingleLine:					false
AllowShortLambdasOnASingleLine:							None
AllowShortLoopsOnASingleLine:							false
AlwaysBreakAfterReturnType:								None
AlwaysBreakBeforeMultilineStrings:						false
AlwaysBreakTemplateDeclarations:						Yes
BasedOnStyle:											Google
BinPackArguments:										false
BinPackParameters:										false
BreakBeforeBinaryOperators:								None
BreakBeforeBraces:										Allman
BreakBeforeTernaryOperators:							true
BreakConstructorInitializers:							BeforeComma
BreakInheritanceList:									BeforeComma
BreakStringLiterals:									true
ColumnLimit:											100
CompactNamespaces:										false
ConstructorInitializerAllOnOneLineOrOnePerLine:			false
ConstructorInitializerIndentWidth:						4
ContinuationIndentWidth:								4
Cpp11BracedListStyle:									true
DerivePointerAlignment:									false
FixNamespaceComments:									true
IncludeBlocks:											Merge
IndentCaseLabels:										true
IndentGotoLabels:										false
IndentPPDirectives:										BeforeHash
IndentWidth:											4
IndentWrappedFunctionNames:								false
KeepEmptyLinesAtTheStartOfBlocks:						false
Language:												Cpp
MaxEmptyLinesToKeep:									3
NamespaceIndentation:									None
ObjCBinPackProtocolList:								Auto
ObjCBlockIndentWidth:									4
ObjCSpaceAfterProperty:									true
ObjCSpaceBeforeProtocolList:							true
PointerAlignment:										Left
ReflowComments:											false
SortIncludes:											true
SortUsingDeclarations:									true
SpaceAfterCStyleCast:									true
SpaceAfterLogicalNot:									false
SpaceAfterTemplateKeyword:								false
SpaceBeforeAssignmentOperators:							true
SpaceBeforeCpp11BracedList:								false
SpaceBeforeCtorInitializerColon:						true
SpaceBeforeInheritanceColon:							true
SpaceBeforeParens:										ControlStatements
SpaceBeforeRangeBasedForLoopColon:						true
SpaceInEmptyBlock:										true
SpaceInEmptyParentheses:								false
SpacesBeforeTrailingComments:							4
SpacesInAngles:											false
SpacesInContainerLiterals:								false
SpacesInCStyleCastParentheses:							false
SpacesInParentheses:									false
SpacesInSquareBrackets:									false
Standard:												Latest
TabWidth:												4
UseTab:													ForIndentation
...
FRAGMENT

CONFIG_UNCRUSTIFY=<<FRAGMENT
# ============================================================
# http://uncrustify.sourceforge.net/configuration.txt
# http://uncrustify.sourceforge.net/default.cfg
# ------------------------------------------------------------
input_tab_size											= 4
output_tab_size											= 4
newlines												= lf

utf8_bom												= remove
utf8_byte												= true
utf8_force												= true

mod_case_brace											= remove
mod_full_brace_do										= force
mod_full_brace_for										= force
mod_full_brace_if										= force
mod_full_brace_while									= force
mod_paren_on_return										= remove
mod_remove_empty_return									= true
FRAGMENT


# Comments
#
COMMENT_COPYRIGHT=<<FRAGMENT
/*	NAME:
		TOKEN_FILENAME

	DESCRIPTION:
		TOKEN_DESCRIPTION

	COPYRIGHT:
		Copyright (c) 2006-TOKEN_YEAR, refNum Software
		<http://www.refnum.com/>

		All rights reserved.

TOKEN_LICENSE
	___________________________________________________________________________
*/
FRAGMENT

COMMENT_BAR_TOP											= "\/\/#{'=' * 77}";
COMMENT_BAR_CONTENT										= "\/\/\t\t";
COMMENT_BAR_BOTTOM										= "\/\/#{'-' * 77}";

COMMENT_STANDARD =	{	"include files"					=> "Includes",
						"macros"						=> "Macros",
						"constants"						=> "Constants",
						"types"							=> "Types",
						"class declaration"				=> "Class Declaration",
						"public functions"				=> "Public Functions",

						"internal macros"				=> "Internal Macros",
						"internal constants"			=> "Internal Constants",
						"internal types"				=> "Internal Types",
						"internal functions"			=> "Internal Functions"
					};


# Licenses
#
#
LICENSE_COMMERCIAL=<<FRAGMENT
		This software is distributed under the terms of your licensing
		agreement with refNum Software.
		
		This license grants you permission to use, copy, modify, or
		distribute this sofware only under the terms of that license.
		
		refNum Software retains full ownership of this software.
FRAGMENT

LICENSE_BSD=<<FRAGMENT
		This software is distributed under the BSD-3-Clause license.

		Redistribution and use in source and binary forms, with or without
		modification, are permitted provided that the following conditions
		are met:

			o Redistributions of source code must retain the above
			copyright notice, this list of conditions and the following
			disclaimer.

			o Redistributions in binary form must reproduce the above
			copyright notice, this list of conditions and the following
			disclaimer in the documentation and/or other materials
			provided with the distribution.

			o Neither the name of refNum Software nor the names of its
			contributors may be used to endorse or promote products derived
			from this software without specific prior written permission.

		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
		OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
		LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
		DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
FRAGMENT





#==============================================================================
#		checkTools : Check we have the tools we need.
#------------------------------------------------------------------------------
def checkTools()

	if (PATH_CLANG_FORMAT.empty?)
		abort("Unable to find clang-format!");
	end

	if (PATH_UNCRUSTIFY.empty?)
		abort("Unable to find uncrustify!");
	end

end





#==============================================================================
#		getConfig : Get the config directory.
#------------------------------------------------------------------------------
def getConfig(theArgs)

	# Create the config directory
	#
	# clang-format looks for its configuration relative to the current
	# directory, so we invoke it within the temporary directory that
	# will store our config files.
	pathConfig = Dir.mktmpdir("rn-format");
	Dir.chdir(pathConfig);

	theArgs[:config] = pathConfig;



	# Save the configs
	File.write("#{pathConfig}/.clang-format",				CONFIG_CLANG_FORMAT);
	File.write("#{pathConfig}/#{FILE_CONFIG_UNCRUSTIFY}",	CONFIG_UNCRUSTIFY);

	return pathConfig;

end





#==============================================================================
#		getFiles : Get the files to process.
#------------------------------------------------------------------------------
def getFiles(theArgs)

	theFiles = [];

	theArgs[:paths].each do |pathRoot|

		Find.find(pathRoot) do |thePath|
			if (File.file?(thePath))
				theFiles << thePath;
			end
		end
	end

	return theFiles;

end





#==============================================================================
#		splitLines : Split text into lines.
#------------------------------------------------------------------------------
def splitLines(theText)

	theLines = [];
	
	theText.each_line do |theLine|
	
		if (theLine =~ /^(.*?)(\/\/.*)/)
			lineText    = $1;
			lineComment = $2;
		else
			lineText    = theLine.chomp;
			lineComment = "";
		end

		theLines << { :text => lineText, :comment => lineComment };
	
	end

	return theLines;

end





#==============================================================================
#		combineLines : Combine lines back into text.
#------------------------------------------------------------------------------
def combineLines(theLines)

	theText = "";
	
	theLines.each do |theLine|
		theText += theLine[:text] + theLine[:comment] + "\n";
	end

	return theText;

end





#==============================================================================
#		isLineEmpty : Is a line empty?
#------------------------------------------------------------------------------
def isLineEmpty(theLine)

	return theLine[:text].empty? && theLine[:comment].empty?
end





#==============================================================================
#		getEmptyLine : Get an empty line.
#------------------------------------------------------------------------------
def getEmptyLine()

	return { :text => "", :comment => "" };

end





#==============================================================================
#		formatComments : Format comment blocks.
#------------------------------------------------------------------------------
def formatComments(theLines)

	theLines.each_with_index do |theLine, theIndex|

		if (theIndex >= 2)
		
			line0 = theLines[theIndex - 2];
			line1 = theLines[theIndex - 1];
			line2 = theLines[theIndex - 0];
			
			if (line0[:text].empty? &&
				line1[:text].empty? &&
				line2[:text].empty? &&

				line0[:comment] =~ /^\/\/==========+/ &&
				line2[:comment] =~ /^\/\/----------+/ &&
				line1[:comment] =~ /^\/\/\s*(.*)/    )


				# Fix up standard blocks
				theComment = $1;
				commentKey = $1.chomp('.').downcase;

				if (COMMENT_STANDARD.has_key?(commentKey))
					theComment = COMMENT_STANDARD[commentKey];


				# Fix up function blocks
				else
					# Split the comment
					if (theComment =~ /^(.*):\s*(.*)$/)
						theName = $1.strip;
						theDesc = $2.strip.chomp(".");
					
					else
						theName = theComment;
						theDesc = "";
					end


					# Normalise the description
					if (theName =~ /^(\w+)::\1$/)
						theDesc = "Constructor.";
					
					elsif (theName =~ /^(\w+)::~\1$/)
						theDesc = "Destructor.";
					
					elsif (theDesc.empty?)
						theDesc = "MISSING DESCRIPTION.";
					end
				
					if (!theDesc.end_with?(".", "?", "!"))
						theDesc += ".";
					end
					
					theComment = theName + " : " + theDesc;
				end



				# Rewrite the the comment
				theLines[theIndex - 2][:comment] = COMMENT_BAR_TOP;
				theLines[theIndex - 1][:comment] = COMMENT_BAR_CONTENT + theComment;
				theLines[theIndex - 0][:comment] = COMMENT_BAR_BOTTOM;
			end
		
		end
	end

	return theLines;

end





#==============================================================================
#		formatGroups : Format groups.
#------------------------------------------------------------------------------
def formatGroups(theLines)

	newLines = [];
	theLines.each_with_index do |theLine, theIndex|

		# Five spaces before comment block
		#
		# clang-format is set to reduce blank lines to three, so we
		# can add two blank lines before a comment block to create
		# five blank lines between groups.
		if (theLine[:text].empty? && theLine[:comment] == COMMENT_BAR_TOP)
		
			prevLine = theLines[theIndex - 1];
			
			if (isLineEmpty(prevLine) || prevLine[:text] =~ /^#pragma/)
				newLines.insert(newLines.size - 1, getEmptyLine());
				newLines.insert(newLines.size - 1, getEmptyLine());
			end

		end
		
		newLines << theLine;
	
	end

	return newLines;

end





#==============================================================================
#		rewriteCopyright : Rewrite the copyright.
#------------------------------------------------------------------------------
def rewriteCopyright(theText, theFile)

	# Rewrite the copyright
	#
	# The copyright is assumed to follow a standard format.
	theMatch = /\/\*.*NAME:\s+.*?\n.*?DESCRIPTION:\s+(.*)\n.*?COPYRIGHT:.*?\*\//m.match(theText);

	if (theMatch != nil)
	
		# Normalise the description
		theDesc = theMatch[1].rstrip;
		if (theDesc.empty?)
			theDesc = "MISSING DESCRIPTION.";
		
		elsif (!theDesc.end_with?("."))
			theDesc += ".";
		end



		# Identify the license
		if (theText.include?("This software is distributed under the BSD-3-Clause license") ||
			theText.include?("Released under the terms of licence.html"))
			theLicense = LICENSE_BSD;
		else
			theLicense = LICENSE_COMMERCIAL;
		end



		# Rewrite the copyright
		theCopyright = COMMENT_COPYRIGHT.dup();
		theCopyright.sub!("TOKEN_FILENAME",		File.basename(theFile));
		theCopyright.sub!("TOKEN_DESCRIPTION",	theDesc);
		theCopyright.sub!("TOKEN_YEAR",			Time.now.year.to_s);
		theCopyright.sub!("TOKEN_LICENSE",		theLicense.chomp);
		
		theText[theMatch.begin(0)..theMatch.end(0)] = theCopyright;
	end
	
	return theText;

end





#==============================================================================
#		reformattedFile : Reformat a file.
#------------------------------------------------------------------------------
def reformattedFile(theArgs, theFile)

	# Apply the formatters
	#
	# uncrustify is used to perform code transformations, such as
	# adjusting parentheses or braces.
	#
	# clang-format is then used to perform code reformatting.
	#
	pathConfigUC = "#{theArgs[:config]}/#{FILE_CONFIG_UNCRUSTIFY}";
	
	theText =	`cat "#{theFile}"                                   | \
				"#{PATH_UNCRUSTIFY}" -q -l CPP -c "#{pathConfigUC}" | \
				"#{PATH_CLANG_FORMAT}" -style=file`;



	# Apply additional rules
	if (!theArgs[:clang])
		theLines = splitLines(    theText);
		theLines = formatComments(theLines);
		theLines = formatGroups(  theLines);

		theText = combineLines(    theLines);
		theText = rewriteCopyright(theText, theFile);
	end

	return theText;

end





#==============================================================================
#		reformatFile : Reformat a file.
#------------------------------------------------------------------------------
def reformatFile(theArgs, theFile)

	# Reformat the file
	oldText = File.read(theFile);
	newText = reformattedFile(theArgs, theFile);


	# Rewrite it
	if (theArgs[:rewrite])
		if (newText != oldText)
			puts "Reformatted "#{theFile}";
			File.write(theFile, newText);
		end
	else
		puts newText;
	end

end





#==============================================================================
#		reformatFiles : Reformat the files.
#------------------------------------------------------------------------------
def reformatFiles(theArgs)

	# Get the state we need
	pathConfig = getConfig(theArgs);
	theFiles   = getFiles( theArgs);



	# Reformat the files
	theFiles.each do |theFile|
		reformatFile(theArgs, theFile)
	end
	
	FileUtils.rm_rf(pathConfig);

end





#==============================================================================
#		getArguments : Get the arguments.
#------------------------------------------------------------------------------
def getArguments

	# Parse the arguments
	theArgs = { :clang   => false,
				:rewrite => false,
				:help    => false,
				:paths   => [] }

	theParser = OptionParser.new do |opts|
		opts.banner    = "Usage:\n    rn-format [--help] [--clang] [--rewrite] PATH [PATH...]";
		opts.separator "";
		opts.separator "Reformat any source files within the supplied paths,";
		opts.separator "displaying the results to standard output.";
		opts.separator "";
		opts.separator "Options:";

		opts.on('-c', '--clang',					'Show raw clang-format output') do
			theArgs[:clang] = true;
		end

		opts.on('-r', '--rewrite',					'Rewrite files in-place') do
			theArgs[:rewrite] = true;
		end

		opts.on('-h', '--help',						'Show the help') do
			theArgs[:help] = true;
		end
	end

	theParser.parse!;
	theArgs[:paths] = ARGV;



	# Show the help
	if (theArgs[:help] || theArgs[:paths].empty?)
		puts theParser.help();
		exit(false);
	end
	
	return theArgs;

end





#==============================================================================
#		rnformat : Code reformatter.
#------------------------------------------------------------------------------
def rnformat

	# Get the state we need
	checkTools();
	
	theArgs = getArguments();



	# Reformat the files
	reformatFiles(theArgs);

end

rnformat();

