#!/usr/bin/ruby -w
#==============================================================================
#	NAME:
#		rn-format
#
#	DESCRIPTION:
#		clang-format source code formatter.
#
#	COPYRIGHT:
#		Copyright (c) 2019, refNum Software
#		All rights reserved.
#
#		Redistribution and use in source and binary forms, with or without
#		modification, are permitted provided that the following conditions
#		are met:
#		
#		1. Redistributions of source code must retain the above copyright
#		notice, this list of conditions and the following disclaimer.
#		
#		2. Redistributions in binary form must reproduce the above copyright
#		notice, this list of conditions and the following disclaimer in the
#		documentation and/or other materials provided with the distribution.
#		
#		3. Neither the name of the copyright holder nor the names of its
#		contributors may be used to endorse or promote products derived from
#		this software without specific prior written permission.
#		
#		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#		"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#		LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#		A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#		HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#		SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#		LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#		DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#		THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#		(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#		OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#==============================================================================
#		Imports
#------------------------------------------------------------------------------
require 'fileutils';
require 'find';
require 'optparse';
require 'tmpdir';





#==============================================================================
#		Constants
#------------------------------------------------------------------------------
# Paths
#
PATH_CLANG_FORMAT = `which clang-format`.chomp;
PATH_UNCRUSTIFY   = `which uncrustify`.chomp;

FILE_CONFIG_UNCRUSTIFY = "uncrustify.cfg";


# Configuration
#
CONFIG_CLANG_FORMAT=<<FRAGMENT
# ============================================================
# https://clang.llvm.org/docs/ClangFormatStyleOptions.html
# ------------------------------------------------------------
---
AccessModifierOffset:									-4
AlignAfterOpenBracket:									Align
AlignConsecutiveAssignments:							true
AlignConsecutiveDeclarations:							true
AlignConsecutiveMacros:									true
AlignEscapedNewlines:									Left
AlignOperands:											true
AlignTrailingComments:									true
AllowAllArgumentsOnNextLine:							false
AllowAllConstructorInitializersOnNextLine:				false
AllowAllParametersOfDeclarationOnNextLine:				false
AllowShortBlocksOnASingleLine:							false
AllowShortCaseLabelsOnASingleLine:						false
AllowShortFunctionsOnASingleLine:						None
AllowShortIfStatementsOnASingleLine:					false
AllowShortLambdasOnASingleLine:							None
AllowShortLoopsOnASingleLine:							false
AlwaysBreakAfterReturnType:								None
AlwaysBreakBeforeMultilineStrings:						false
AlwaysBreakTemplateDeclarations:						Yes
BasedOnStyle:											Google
BinPackArguments:										false
BinPackParameters:										false
BreakBeforeBinaryOperators:								None
BreakBeforeBraces:										Allman
BreakBeforeTernaryOperators:							true
BreakConstructorInitializers:							BeforeComma
BreakInheritanceList:									BeforeComma
BreakStringLiterals:									true
ColumnLimit:											100
CompactNamespaces:										false
ConstructorInitializerAllOnOneLineOrOnePerLine:			false
ConstructorInitializerIndentWidth:						4
ContinuationIndentWidth:								4
Cpp11BracedListStyle:									true
DerivePointerAlignment:									false
FixNamespaceComments:									true
IncludeBlocks:											Merge
IndentCaseLabels:										true
IndentGotoLabels:										false
IndentPPDirectives:										BeforeHash
IndentWidth:											4
IndentWrappedFunctionNames:								false
KeepEmptyLinesAtTheStartOfBlocks:						false
MaxEmptyLinesToKeep:									3
NamespaceIndentation:									None
ObjCBinPackProtocolList:								Auto
ObjCBlockIndentWidth:									4
ObjCSpaceAfterProperty:									true
ObjCSpaceBeforeProtocolList:							true
PointerAlignment:										Left
ReflowComments:											false
SortIncludes:											true
SortUsingDeclarations:									true
SpaceAfterCStyleCast:									true
SpaceAfterLogicalNot:									false
SpaceAfterTemplateKeyword:								false
SpaceBeforeAssignmentOperators:							true
SpaceBeforeCpp11BracedList:								false
SpaceBeforeCtorInitializerColon:						true
SpaceBeforeInheritanceColon:							true
SpaceBeforeParens:										ControlStatements
SpaceBeforeRangeBasedForLoopColon:						true
SpaceInEmptyBlock:										true
SpaceInEmptyParentheses:								false
SpacesBeforeTrailingComments:							4
SpacesInAngles:											false
SpacesInContainerLiterals:								false
SpacesInCStyleCastParentheses:							false
SpacesInParentheses:									false
SpacesInSquareBrackets:									false
Standard:												Latest
TabWidth:												4
UseTab:													Never
...
FRAGMENT

CONFIG_UNCRUSTIFY=<<FRAGMENT
# ============================================================
# http://uncrustify.sourceforge.net/configuration.txt
# http://uncrustify.sourceforge.net/default.cfg
# ------------------------------------------------------------
input_tab_size											= 4
output_tab_size											= 4
newlines												= lf

utf8_bom												= remove
utf8_byte												= true
utf8_force												= true

mod_case_brace											= remove
mod_full_brace_do										= force
mod_full_brace_for										= force
mod_full_brace_if										= force
mod_full_brace_while									= force
mod_paren_on_return										= remove
mod_remove_empty_return									= true
FRAGMENT

CONFIG_TAB_WIDTH										= 4
CONFIG_ALIGN_LINES										= 10;

CONFIG_ALIGN_SLIDE										= CONFIG_TAB_WIDTH * 3;
CONFIG_ALIGN_MEMBER										= CONFIG_TAB_WIDTH * 10;
CONFIG_ALIGN_ASSIGNMENT									= CONFIG_TAB_WIDTH * 15;


# Comments
#
COMMENT_COPYRIGHT=<<FRAGMENT
/*	NAME:
		TOKEN_FILENAME

	DESCRIPTION:
		TOKEN_DESCRIPTION

	COPYRIGHT:
		Copyright (c) 2006-TOKEN_YEAR, refNum Software
		All rights reserved.

TOKEN_LICENSE
	___________________________________________________________________________
*/
FRAGMENT

COMMENT_BAR_TOP											= "\/\/#{'=' * 77}";
COMMENT_BAR_CONTENT										= "\/\/\t\t";
COMMENT_BAR_BOTTOM										= "\/\/#{'-' * 77}";

COMMENT_STANDARD =	{	"include files"					=> "Includes",
						"macros"						=> "Macros",
						"constants"						=> "Constants",
						"types"							=> "Types",
						"class declaration"				=> "Class Declaration",
						"public functions"				=> "Public Functions",

						"internal macros"				=> "Internal Macros",
						"internal constants"			=> "Internal Constants",
						"internal types"				=> "Internal Types",
						"internal functions"			=> "Internal Functions"
					};


# Licenses
#
LICENSE_COMMERCIAL=<<FRAGMENT
		This software is distributed under the terms of your licensing
		agreement with refNum Software.
		
		This license grants you permission to use, copy, modify, or
		distribute this sofware only under the terms of that license.
		
		refNum Software retains full ownership of this software.
FRAGMENT

LICENSE_BSD=<<FRAGMENT
		Redistribution and use in source and binary forms, with or without
		modification, are permitted provided that the following conditions
		are met:
		
		1. Redistributions of source code must retain the above copyright
		notice, this list of conditions and the following disclaimer.
		
		2. Redistributions in binary form must reproduce the above copyright
		notice, this list of conditions and the following disclaimer in the
		documentation and/or other materials provided with the distribution.
		
		3. Neither the name of the copyright holder nor the names of its
		contributors may be used to endorse or promote products derived from
		this software without specific prior written permission.
		
		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
		HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
		LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
		DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
FRAGMENT


# Lines
EMPTY_LINE = { :text => "", :comment => "" };





#==============================================================================
#		checkTools : Check we have the tools we need.
#------------------------------------------------------------------------------
def checkTools()

	if (PATH_CLANG_FORMAT.empty?)
		abort("Unable to find clang-format!");
	end

	if (PATH_UNCRUSTIFY.empty?)
		abort("Unable to find uncrustify!");
	end

end





#==============================================================================
#		getConfig : Get the config directory.
#------------------------------------------------------------------------------
def getConfig(theArgs)

	# Create the config directory
	#
	# clang-format looks for its configuration relative to the current
	# directory, so we invoke it within the temporary directory that
	# will store our config files.
	pathConfig = Dir.mktmpdir("rn-format");
	Dir.chdir(pathConfig);

	theArgs[:config] = pathConfig;



	# Save the configs
	File.write("#{pathConfig}/.clang-format",				CONFIG_CLANG_FORMAT);
	File.write("#{pathConfig}/#{FILE_CONFIG_UNCRUSTIFY}",	CONFIG_UNCRUSTIFY);

	return pathConfig;

end





#==============================================================================
#		getFiles : Get the files to process.
#------------------------------------------------------------------------------
def getFiles(theArgs)

	theFiles = [];

	theArgs[:paths].each do |pathRoot|

		Find.find(pathRoot) do |thePath|
			if (File.file?(thePath))
				theFiles << thePath;
			end
		end
	end

	return theFiles;

end





#==============================================================================
#		splitLines : Split text into lines.
#------------------------------------------------------------------------------
def splitLines(theText)

	theLines = [];
	
	theText.each_line do |theLine|
	
		if (theLine =~ /^(.*?)(\/\/.*)/)
			lineText    = $1;
			lineComment = $2;
		else
			lineText    = theLine.chomp;
			lineComment = "";
		end

		theLines << { :text => lineText, :comment => lineComment };
	
	end

	return theLines;

end





#==============================================================================
#		combineLines : Combine lines back into text.
#------------------------------------------------------------------------------
def combineLines(theLines)

	theText = "";
	
	theLines.each do |theLine|
		theText += theLine[:text] + theLine[:comment] + "\n";
	end

	return theText;

end





#==============================================================================
#		isLineEmpty : Is a line empty?
#------------------------------------------------------------------------------
def isLineEmpty(theLine)

	return theLine[:text].empty? && theLine[:comment].empty?
end





#==============================================================================
#		getLine : Get a line from an array.
#------------------------------------------------------------------------------
def getLine(theLines, theIndex)

	return theLines.fetch(theIndex, EMPTY_LINE);

end





#==============================================================================
#		replaceVoids : Replace '(void)' parameters.
#------------------------------------------------------------------------------
def replaceVoids(theLines)

	theLines.each do |theLine|
		theLine[:text].gsub!(/\(\s*void\s*\)/, '()');
	end
	
end





#==============================================================================
#		spaceMethods : Space methods within a class.
#------------------------------------------------------------------------------
def spaceMethods(theLines)

	theLines.each_with_index do |theLine, theIndex|
	
		# Two blank lines before method comment
		if (theLine[:text] =~ /^    / && !theLine[:comment].empty?)
		
			# Get the state we need
			lineMinus3 = theLines[theIndex - 3];
			lineMinus2 = theLines[theIndex - 2];
			lineMinus1 = theLines[theIndex - 1];


			# 3 blank lines
			if (isLineEmpty(lineMinus1) && isLineEmpty(lineMinus2) && isLineEmpty(lineMinus3))
				theLines.delete_at(theIndex - 2);

			# 1 blank line
			elsif (isLineEmpty(lineMinus1) && !isLineEmpty(lineMinus2))
				theLines.insert(theIndex, EMPTY_LINE);

			# 0 blank lines
			elsif (!isLineEmpty(lineMinus1))
				theLines.insert(theIndex, EMPTY_LINE);
				theLines.insert(theIndex, EMPTY_LINE);
			end

		end
	end

end





#==============================================================================
#		indentMembers : Indent members within a class.
#------------------------------------------------------------------------------
def indentMembers(theLines)

	paramIndent = 0;
	indentType = (" " * CONFIG_TAB_WIDTH);

	theLines.each_with_index do |theLine, theIndex|
	
		# Get the state we need
		theText = theLine[:text];


		# Constructors
		if (theText =~ /^    (\w+)(\(.*)/)
			methodName   = $1;
			methodParams = $2;
			
			spanSize = CONFIG_ALIGN_MEMBER;
			theText = (" " * spanSize) + methodName + methodParams;
			
			if (theText.end_with?(","))
				paramIndent = theText.size() - methodParams.size() + 1;
			end


		# Destructors
		elsif (theText =~ /^(.*)(\s~\w+)(\(.*)/)
			methodVirtual = $1.strip;
			methodName    = $2.strip;
			methodParams  = $3;
			
			spanSize = CONFIG_ALIGN_MEMBER - 2;
			theText = (indentType + methodVirtual).ljust(spanSize) + " " + methodName + methodParams;


		# Methods
		elsif (theText =~ /^    (\w.*?)\s+(\w+)(\(.*)/ ||
			   theText =~ /^    (\w.*?)\s+(operator.+)(\(.*)/)
			methodType   = $1;
			methodName   = $2;
			methodParams = $3;
			
			if (methodType =~ /(.*)\s+operator$/)
				methodType = $1;
				methodName = "operator #{methodName}";
			end

			if (methodType == "operator")
				methodType = "";
				methodName = "operator #{methodName}";
			end

			spanSize = CONFIG_ALIGN_MEMBER - 1;
			theText = (indentType + methodType).ljust(spanSize) + " " + methodName + methodParams;
					
			if (theText.end_with?(","))
				paramIndent = theText.size() - methodParams.size() + 1;
			end


		# Members
		elsif (theText =~ /^    (\w.*?)\s+(\w+;)/ ||
			   theText =~ /^    (\w.*?)\s+(\w+\[.+;)/)
		
			memberType = $1;
			memberName = $2;
			
			spanSize = CONFIG_ALIGN_MEMBER - 1;
			theText = (indentType + memberType).ljust(spanSize) + " " + memberName;


		# Parameters
		elsif (paramIndent != 0)
			theText.sub!(/^\s+/, " " * paramIndent);
			
			if (theText.include?(")"))
				paramIndent = 0;
			end
		end


		# Update the line
		theLine[:text] = theText;
	
	end

end





#==============================================================================
#		findTokenInText : Find a token within some text.
#------------------------------------------------------------------------------
def findTokenInText(theText, theToken, findAfter)

	if (findAfter == nil)
		theOffset = theText.index(theToken);
	else
		theOffset = theText.index(findAfter);
		if (theOffset != nil)
			theOffset = theText.index(theToken, theOffset);
		end
	end
	
	return theOffset;

end





#==============================================================================
#		findTokenInLine : Find a token within a line.
#------------------------------------------------------------------------------
def findTokenInLine(theLine, theToken, findAfter)

	theText   = theLine[:text];
	theOffset = nil;

	if (theText.include?('"'))
		baseOffset = 0;
		theText.split('"').each_with_index do |theChunk, theIndex|

			insideQuote = theIndex.odd?
			if (insideQuote)
				baseOffset += 2;
			else
				theOffset = findTokenInText(theChunk, theToken, findAfter);
				if (theOffset != nil)
					return baseOffset + theOffset;
				end
			end

			baseOffset += theChunk.size;
		end 
	else
		theOffset = findTokenInText(theText, theToken, findAfter);
	end

	return theOffset;

end





#==============================================================================
#		alignEndifs : Align #endif.
#------------------------------------------------------------------------------
def alignEndifs(theLines)

	# Collapse whitespace after #endif
	#
	# clang-format inserts IndentWidth spaces between a #endif
	# and its comment.
	theLines.each do |theLine|

		if (theLine[:text] =~ /^(#endif\s)\s+/ && !theLine[:comment].empty?)
			theLine[:text] = $1;
		end

	end

end





#==============================================================================
#		alignContinuations : Align line continuations.
#------------------------------------------------------------------------------
def alignContinuations(theLines)

	theLines.each do |theLine|

		if (theLine[:text] =~ /^(.*)\s+\\$/ && theLine[:comment].empty?)
			theText = $1;
			
			if (theText.size < CONFIG_ALIGN_ASSIGNMENT)
				theLine[:text] = theText.ljust(CONFIG_ALIGN_ASSIGNMENT) + "\\";
			end
		end

	end

end





#==============================================================================
#		alignTokens : Align consecutive tokens.
#------------------------------------------------------------------------------
def alignTokens(theLines, matchLine, matchTokens, findAfter=nil)

	# Align the tokens
	#
	# Tokens that appear on consecutive lines are aligned to the
	# rightmost instance of that token across that group of lines.
	theLines.each_with_index do |theLine, theIndex|
		if (matchLine.match(theLine[:text]))

			# Build the order
			#
			# Tokens are processed in the order that they appear on the line,
			# so that we always extend existing alignment from left to right.
			tokenOrder = Hash.new();
			
			matchTokens.each do |theToken|
				tokenOffset = findTokenInLine(theLine, theToken, findAfter);
				
				if (tokenOffset != nil)
					tokenOrder[tokenOffset] = theToken;
				end
			end



			# Align the tokens
			tokenOrder.keys.sort.each do |tokenOffset|

				# Find the token on this line
				theToken  = tokenOrder[tokenOffset];
				theOffset = findTokenInLine(theLine, theToken, findAfter);

				if (theOffset != nil)
					# Find on previous lines
					theOffsets = [theOffset];
				
					for n in 1..CONFIG_ALIGN_LINES do
						lineMinusN = theLines[theIndex - n];
						theOffset  = nil;

						# Find a match
						#
						# Matches that are too far to re-align end the search.
						if (matchLine.match(lineMinusN[:text]))

							theOffset = findTokenInLine(lineMinusN, theToken, findAfter);

							if (theOffset != nil)
								maxOffset   = theOffsets.max;
								offsetDelta = maxOffset - theOffset;

								if (offsetDelta.abs >= CONFIG_ALIGN_SLIDE)
									theOffset = nil;
								end
							end

						end
						
						
						# Stop when can't match
						if (theOffset != nil)
							theOffsets << theOffset;
						else
							break;
						end
					end



					# Align those lines
					if (theOffsets.size > 1)

						# Dump the state before
						maxOffset  = theOffsets.max;
						debugAlign = false;

						if (debugAlign)
							puts "Found #{theOffsets.size} instances of [#{theToken}]:";
							for n in 0...theOffsets.size do
								theOffset   = theOffsets[n];
								offsetDelta = maxOffset - theOffset;

								puts "[#{n}] [#{theLines[theIndex - n][:text]}]";
								puts "     " + (" " * theOffset) + "^ (#{offsetDelta} from max offset)";
							end
						end


						# Apply the alignment
						for n in 0...theOffsets.size do
							theOffset   = theOffsets[n];
							offsetDelta = maxOffset - theOffset;
						
							if (offsetDelta >= 0 && offsetDelta < CONFIG_ALIGN_SLIDE)
								padAlign = " " * offsetDelta;
								theLines[theIndex - n][:text].insert(theOffset, padAlign);
							end
						end


						# Dump the state after
						if (debugAlign)
							puts "After aligning [#{theToken}]";
							for n in 0...theOffsets.size do
								puts "[#{n}] [#{theLines[theIndex - n][:text]}]";
							end
							puts "";
						end

					end
				end

			end

		end
	end


end





#==============================================================================
#		alignParams : Align method parameters.
#------------------------------------------------------------------------------
def alignParams(theLines)

	# Collect the parameters
	#
	# Nested parameters are replaced with commas, allowing them to
	# be discarded when the parameter list is converted to tokens.
	theParams = [];

	theLines.each do |theLine|
		if (theLine[:text] =~ /\((.*)\).*;$/)
			theParams << $1.gsub(/[\(\)]/, ",");
		end
	end



	# Build the tokens
	#
	# Alignment can be performed on either type or name.
	theTokens = [];
	
	theParams.each do |theParam|
		theParam.split(",").each do |theToken|
		
			theToken = theToken.gsub(/[*&]/, "").strip;
			
			if (theToken.empty? || theToken =~ /^[\.\-]/)
				# Discard empty params or dereferences
			
			elsif (theToken.include?(" "))
				theTokens.concat(theToken.split(/\s+/));
			
			else
				theTokens << theToken;
			end

		end
	end



	# Align the tokens
	matchTokens = [];
	matchLine   = /\(/;

	theTokens.uniq.each do |theToken|
		matchTokens << Regexp.new(/\b#{Regexp.escape(theToken)}\b/);
	end

	alignTokens(theLines, matchLine, matchTokens, "(");

end





#==============================================================================
#		alignSpecifiers : Align method specifiers.
#------------------------------------------------------------------------------
def alignSpecifiers(theLines)

	# Build the tokens
	theTokens = [	" = 0",
					" = delete",
					" = default",
					" override",
					" final",
					" const" ];



	# Align the tokens
	matchTokens = theTokens;
	matchLine   = /\)/;

	alignTokens(theLines, matchLine, matchTokens, ")");

end





#==============================================================================
#		formatComments : Format comment blocks.
#------------------------------------------------------------------------------
def formatComments(theLines)

	theLines.each_with_index do |theLine, theIndex|

		if (theIndex >= 2)
		
			line0 = theLines[theIndex - 2];
			line1 = theLines[theIndex - 1];
			line2 = theLines[theIndex - 0];
			
			if (line0[:text].empty? &&
				line1[:text].empty? &&
				line2[:text].empty? &&

				line0[:comment] =~ /^\/\/==========+/ &&
				line2[:comment] =~ /^\/\/----------+/ &&
				line1[:comment] =~ /^\/\/\s*(.*)/    )


				# Fix up standard blocks
				theComment = $1;
				commentKey = $1.chomp('.').downcase;

				if (COMMENT_STANDARD.has_value?(theComment))
					# Accept as-is

				elsif (COMMENT_STANDARD.has_key?(commentKey))
					theComment = COMMENT_STANDARD[commentKey];


				# Fix up function blocks
				else
					# Split the comment
					if (theComment =~ /^(.*):\s*(.*)$/)
						theName = $1.strip;
						theDesc = $2.strip.chomp(".");
					
					else
						theName = theComment;
						theDesc = "";
					end


					# Normalise the description
					if (theName =~ /^(\w+)::\1$/)
						theDesc = "Constructor.";
					
					elsif (theName =~ /^(\w+)::~\1$/)
						theDesc = "Destructor.";
					
					elsif (theDesc.empty?)
						theDesc = "MISSING DESCRIPTION.";
					end
				
					if (!theDesc.end_with?(".", "?", "!"))
						theDesc += ".";
					end
					
					theComment = theName + " : " + theDesc;
				end



				# Rewrite the the comment
				theLines[theIndex - 2][:comment] = COMMENT_BAR_TOP;
				theLines[theIndex - 1][:comment] = COMMENT_BAR_CONTENT + theComment;
				theLines[theIndex - 0][:comment] = COMMENT_BAR_BOTTOM;
			end
		
		end
	end

	return theLines;

end





#==============================================================================
#		formatPreprocessor : Format preprocessor directives.
#------------------------------------------------------------------------------
def formatPreprocessor(theLines)

	alignEndifs(		theLines);
	alignContinuations(	theLines);

	return theLines;

end





#==============================================================================
#		formatEnum : Format an enum.
#------------------------------------------------------------------------------
def formatEnum(theLines)
	# TODO
end





#==============================================================================
#		formatStruct : Format a struct.
#------------------------------------------------------------------------------
def formatStruct(theLines)
	# TODO
end





#==============================================================================
#		formatClass : Format a class.
#------------------------------------------------------------------------------
def formatClass(theLines)

	replaceVoids(		theLines);
	spaceMethods(		theLines);
	indentMembers(		theLines);
	alignParams(		theLines);
	alignSpecifiers(	theLines);

end





#==============================================================================
#		formatConstructor : Format a constructor.
#------------------------------------------------------------------------------
def formatConstructor(theLines)

	replaceVoids(theLines);

end





#==============================================================================
#		formatFunction : Format a function.
#------------------------------------------------------------------------------
def formatFunction(theLines)

	replaceVoids(theLines);

end





#==============================================================================
#		formatGlobal : Format a global scope.
#------------------------------------------------------------------------------
def formatGlobal(theLines)
	# TODO
end





#==============================================================================
#		formatScope : Format a scope.
#------------------------------------------------------------------------------
def formatScope(theScope, theLines)

	newLines = theLines.dup;
	
	case theScope
	when :enum
		formatEnum(newLines);
	
	when :struct
		formatStruct(newLines);
	
	when :class
		formatClass(newLines);
	
	when :constructor
		formatConstructor(newLines);

	when :function
		formatFunction(newLines);
	
	when :global
		formatGlobal(newLines);
	end
	
	return newLines;

end





#==============================================================================
#		identifyScope : Identify a scope.
#------------------------------------------------------------------------------
def identifyScope(theLine, currentScope)

	theText  = theLine[:text];
	newScope = currentScope;
	
	if (theText =~ /^enum /)
		newScope = :enum;
	
	elsif (theText =~ /^struct /)
		newScope = :struct;
	
	elsif (theText =~ /^class /)
		newScope = :class;
	
	elsif (theText =~ /^(\w+)::\1\(/)
		newScope = :constructor;
	
	elsif (theText == "{")
		if (currentScope == :global)
			newScope = :function;
		end
	
	elsif (theText == "}")
		newScope = :global;
	end
	
	return newScope;

end





#==============================================================================
#		formatScopes : Format scopes.
#------------------------------------------------------------------------------
def formatScopes(theLines)

	# Process the lines
	resultLines  = [];
	currentLines = [];
	currentScope = :global;

	theLines.each do |theLine|
	
		# Get the state we need
		theScope     = identifyScope(theLine, currentScope);
		currentLines << theLine;
		
		
		# Switch scope
		if (theScope != currentScope)
			# Push comments
			#
			# Scopes that start with a comment block consume the comment as
			# part of the scope, rather than part of the previous scope.
			newLines = [];
			
			if (theScope == :constructor || theScope == :function)
				while (!currentLines.empty? && !isLineEmpty(currentLines.last()))
					newLines.insert(0, currentLines.pop);
				end
			end
			
			
			# Format the scope
			resultLines += formatScope(currentScope, currentLines);
			currentScope = theScope;
			currentLines = newLines;
		end

	end



	# Close the final scope
	resultLines += formatScope(currentScope, currentLines);
	
	return resultLines;

end





#==============================================================================
#		formatIndents : Format indentation.
#------------------------------------------------------------------------------
def formatIndents(theLines)

	theLines.each do |theLine|
	
		if (theLine[:text] =~ /^(\s+)(.*)/)
			textPrefix = $1;
			textSuffix = $2;
			
			numTabs   = textPrefix.size / CONFIG_TAB_WIDTH;
			numSpaces = textPrefix.size % CONFIG_TAB_WIDTH;

			theLine[:text] = ("\t" * numTabs) + (" " * numSpaces) + textSuffix;
		end

	end
	
	return theLines;

end





#==============================================================================
#		rewriteCopyright : Rewrite the copyright.
#------------------------------------------------------------------------------
def rewriteCopyright(theText, theFile)

	# Rewrite the copyright
	#
	# The copyright is assumed to follow a standard format.
	theMatch = /\/\*.*NAME:\s+.*?\n.*?DESCRIPTION:\s+(.*)\n.*?COPYRIGHT:.*?\*\//m.match(theText);

	if (theMatch != nil)
	
		# Normalise the description
		theDesc = theMatch[1].rstrip;
		if (theDesc.empty?)
			theDesc = "MISSING DESCRIPTION.";
		
		elsif (!theDesc.end_with?("."))
			theDesc += ".";
		end



		# Identify the license
		if (theText.include?("Redistribution and use in source and binary forms") ||
			theText.include?("Released under the terms of licence.html"))
			theLicense = LICENSE_BSD;
		else
			theLicense = LICENSE_COMMERCIAL;
		end



		# Rewrite the copyright
		theCopyright = COMMENT_COPYRIGHT.dup();
		theCopyright.sub!("TOKEN_FILENAME",		File.basename(theFile));
		theCopyright.sub!("TOKEN_DESCRIPTION",	theDesc);
		theCopyright.sub!("TOKEN_YEAR",			Time.now.year.to_s);
		theCopyright.sub!("TOKEN_LICENSE",		theLicense.chomp);
		
		theText[theMatch.begin(0)..theMatch.end(0)] = theCopyright;
	end
	
	return theText;

end





#==============================================================================
#		rewriteHeaderGuard : Rewrite the header guard.
#------------------------------------------------------------------------------
def rewriteHeaderGuard(theText, theFile)

	# Rewrite the header guard
	#
	# The header guard name is derived from the file name.
	if (File.extname(theFile) == ".h")

		theMatch = /#ifndef (\w+)\n#define (\1)\n.*#endif \/\/ (\1)\n/m.match(theText);

		if (theMatch != nil)
			theName = File.basename(theFile);
			theName = theName.split(/(?<=[a-z])(?=[A-Z])/).join("_");
			theName = theName.sub(".", "_").upcase;

			theText[theMatch.begin(3)..theMatch.end(3) - 1] = theName;
			theText[theMatch.begin(2)..theMatch.end(2) - 1] = theName;
			theText[theMatch.begin(1)..theMatch.end(1) - 1] = theName;
		end

	end

	return theText;

end





#==============================================================================
#		rewriteGroups : Rewrite the groups.
#------------------------------------------------------------------------------
def rewriteGroups(theText)

	# Rewrite the groups
	#
	# Five blank lines between groups.
	theText = theText.gsub(/\n\n+#{COMMENT_BAR_TOP}/, "\n\n\n\n\n\n#{COMMENT_BAR_TOP}");

	return theText;

end





#==============================================================================
#		reformattedFile : Reformat a file.
#------------------------------------------------------------------------------
def reformattedFile(theArgs, theFile)

	# Apply the formatters
	#
	# uncrustify is used to perform code transformations, such as
	# adjusting parentheses or braces.
	#
	# clang-format is then used to perform code reformatting.
	#
	pathConfigUC = "#{theArgs[:config]}/#{FILE_CONFIG_UNCRUSTIFY}";
	
	theText =	`cat "#{theFile}"                                   | \
				"#{PATH_UNCRUSTIFY}" -q -l CPP -c "#{pathConfigUC}" | \
				"#{PATH_CLANG_FORMAT}" -style=file`;



	# Apply additional rules
	if (!theArgs[:clang])
		theLines = splitLines(			theText);
		theLines = formatComments(		theLines);
		theLines = formatPreprocessor(	theLines);
		theLines = formatScopes(		theLines);
		theLines = formatIndents(		theLines);

		theText = combineLines(			theLines);
		theText = rewriteCopyright(		theText, theFile);
		theText = rewriteHeaderGuard(	theText, theFile);
		theText = rewriteGroups(		theText);
	end

	return theText;

end





#==============================================================================
#		reformatFile : Reformat a file.
#------------------------------------------------------------------------------
def reformatFile(theArgs, theFile)

	# Reformat the file
	oldText = File.read(theFile);
	newText = reformattedFile(theArgs, theFile);


	# Rewrite it
	if (theArgs[:rewrite])
		if (newText != oldText)
			puts "Reformatted #{theFile}";
			File.write(theFile, newText);
		end
	else
		puts newText;
	end

end





#==============================================================================
#		reformatFiles : Reformat the files.
#------------------------------------------------------------------------------
def reformatFiles(theArgs)

	# Get the state we need
	pathConfig = getConfig(theArgs);
	theFiles   = getFiles( theArgs);



	# Reformat the files
	theFiles.each do |theFile|
		reformatFile(theArgs, theFile)
	end
	
	FileUtils.rm_rf(pathConfig);

end





#==============================================================================
#		getArguments : Get the arguments.
#------------------------------------------------------------------------------
def getArguments

	# Parse the arguments
	theArgs = { :clang   => false,
				:rewrite => false,
				:help    => false,
				:paths   => [] }

	theParser = OptionParser.new do |opts|
		opts.banner    = "Usage:\n    rn-format [--help] [--clang] [--rewrite] PATH [PATH...]";
		opts.separator "";
		opts.separator "Reformat any source files within the supplied paths,";
		opts.separator "displaying the results to standard output.";
		opts.separator "";
		opts.separator "Options:";

		opts.on('-c', '--clang',					'Show raw clang-format output') do
			theArgs[:clang] = true;
		end

		opts.on('-r', '--rewrite',					'Rewrite files in-place') do
			theArgs[:rewrite] = true;
		end

		opts.on('-h', '--help',						'Show the help') do
			theArgs[:help] = true;
		end
	end

	theParser.parse!;
	theArgs[:paths] = ARGV;



	# Show the help
	if (theArgs[:help] || theArgs[:paths].empty?)
		puts theParser.help();
		exit(false);
	end
	
	return theArgs;

end





#==============================================================================
#		rnformat : Code reformatter.
#------------------------------------------------------------------------------
def rnformat

	# Get the state we need
	checkTools();
	
	theArgs = getArguments();



	# Reformat the files
	reformatFiles(theArgs);

end

rnformat();

